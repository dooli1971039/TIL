# CH07 객체지향 프로그래밍 2

## 상속

-   기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

```java
public Class Parent{ .... }; // 부모 클래스
public Class Child extends parent { .... }; // 자식 클래스
```

-   자바는 다중 상속을 허용하지 않는다.
-   자손 클래스는 조상 클래스의 모든 멤버를 상속받는다.
-   단, 생성자와 초기화블럭은 상속되지 않는다.
-   자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

## 포함 관계

-   상속 이외에도 클래스를 재사용하는 또 다른 방법에 **포함 관계(Composite)**가 있다.
-   포함 관계 : **한 클래스의 멤버변수로 다른 클래스 타임의 참조변수를 선언하는 것**

> 원은 점이다 -> ~은 ~이다 -> **is-a** -> 상속 관계  
> 원은 점을 가지고 있다 -> ~은 ~을 가지고 있다 -> **has-a** -> 포함 관계

## 단일 상속

-   Java에서는 단 하나의 조상 클래스로부터 상속이 가능하다.(**단일 상속**)
-   클래스 간의 관계가 다중 상속보다 명확해지고, 코드를 더욱 신뢰할 수 있다는 특징이 있다.

> **다중 상속**을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 특징이 있지만, 클래스간의 관계가 매우 복잡해진다는 것과 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점이 있다.

## Object 클래스

-   Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다.
-   다른 클래스로부터 상속 받지 않는 모든 클래스는 자동적으로 Object 클래스로부터 상속받게 한다.

## 오버라이딩(overriding)

-   조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 **오버라이딩**이라고 한다.
-   조건은 아래와 같다.
    1. 선언부(메서드 이름, 매개변수, 반환 타입)가 조상 클래스의 메서드와 일치해야 한다.
    2. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 있다. (public > protected > defualt > private)
    3. 조상 클래의 메서드보다 많은 수의 예외를 선언할 수 없다 (throws ~ 부분)

## 오버로딩 vs 오버라이딩

-   오버라이딩 : **조상 클래스로부터** 상속받은 메서드를 변경(**재정의**)
-   오버로딩 : **한 클래스 내에** 같은 이름의 메서드를 여러 개 정의하는 것 == 기존에 없는 **새로운 메서드를 정의**하는 것

## 참조변수 super

-   super는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
-   멤버변수와 지역변수의 이름이 같을 때 this를 사용했던 것처럼, 상속받은 멤버와 자신의 멤버가 이름이 같을 때 super를 붙여서 구별할 수 있다.

## super() - 조상의 생성자

-   this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만, super()는 조상의 생성자를 호출하는데 사용된다.
-   **생성자는 상속되지 않는다**는 것을 잊지 말자

## Package

-   클래스의 묶음
-   패키지에는 클래스 or 인터페이스를 포함시킬 수 있으며, 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.
-   **package 패키지명;** 으로 선언한다.
-   패키지 선언문은 반드시 소스파일에서 첫 번째 문자이어야 하며, 하나의 소스파일에 한 번만 선언될 수 있다.
-   대소문자를 모두 허용하나, 원칙적으로 **소문자**로 적는다.
-   모든 클래스는 반드시 하나의 패키지에 포함되어야 하나, 패키지를 명시하지 않은 경우 Java에서 제공하는 unnamed package에 포함된다.

## import

-   import로 패키지를 미리 명시해주면, 소스코드에서 사용되는 클래스 이름에서 패키지명은 생략할 수 있다.
-   **import 패키지명.클래스명;** 또는 **import 패키지명.\*;** 으로 선언한다. (실행 시 성능상의 차이는 전혀 없다)
-   import문을 사용하면 클래스의 패키지명을 생략할 수 있는 것과 같이, **static import**문을 사용하면 static 멤버를 호출할 떄 클래스 이름을 생략할 수 있다.  
    ex) import static java.lang.Math.\*; -> Math.random() 대신 random()으로 사용 가능

## 제어자(modifier)

-   제어자는 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.
-   크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.
-   제어자는 하나의 대상에 대해서 여러 제어자를 조합하여 사용할 수 있다.  
    단, 접근 제어자는 한 번에 네 가지 중 하나만 선택해서 사용할 수 있다.

> 접근 제어자 : public, protected, default, private  
> 그 외의 제어자 : static, final, abstract, native, transient, synchronized, volatile, strictfp

### static

-   '클래스의', '공통적인'의 의미를 갖는다.
-   인스턴스 변수는 하나의 클래스로부터 생성되었더락도 각기 다른 값을 유지하지만, 클래스 변수는 인스턴스에 관계없이 같은 값을 갖는다.
-   static이 붙은 멤버변수와 메서드, 그리고 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것이기 때문에 인스턴스를 생성하지 않고도 사용할 수 있다.
    > static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

![image](https://user-images.githubusercontent.com/70802352/214758737-de3f9767-804c-4c0f-9986-04cf96479ec1.png)

### final

-   '마지막의', '변경될 수 없는'의 의미를 갖는다.
-   거의 모든 대상에 사용될 수 있으며, 변수에 사용되면 값을 변경할 수 없는 상수가 되고, 메서드에 사용되면 오버라이딩을 할 수 없게 되고, 클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.
    > final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

![image](https://user-images.githubusercontent.com/70802352/214758931-b322b874-475e-4b3b-a537-803bd68723b8.png)

### abstract

-   '추상의', '미완성의'의 의미를 갖는다.
-   메서드의 선언부만 작성하고 실제 내용을 구현하지 않는 추상메서드를 선언하는데 사용된다.
-   추상 클래스는 아직 완성되지 않은 메서드가 존재하는 '미완성 설계도'이므로 인스턴스를 생성할 수 없다.

> abstract가 사용될 수 있는 곳 - 클래스, 메서드

![image](https://user-images.githubusercontent.com/70802352/214759153-eb71d257-c9e7-4dca-8ce4-91f0411eeb96.png)

### 접근 제어자(access modifier)

-   접근 제어자는 멤버 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하게 제한하는 역할을 한다.
-   접근 제어자가 default임을 알리기 위해 실제로 default를 붙이지는 않는다. (생략하면 default임)
-   public > protected > default > private
    > 접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자

![image](https://user-images.githubusercontent.com/70802352/214759403-eefdaf9c-a9c3-475b-9d77-86f0293d5589.png)

## 캡슐화와 접근 제어자

-   클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.
-   데이터가 유효한 값을 유지하도록, 또는 외부에서 함부로 변경하지 못하도록 하기 위해서는 외부로부터의 접근을 제어하는 것이 필요하며, 이를 데이터 감추기(data hiding)이라 한다.  
    => **객체지향개념의 캡슐화(encapsulation)**

-   또 다른 이유는 클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버변수나 부분작업을 처리하기 위한 메서드 등의 멤버들을 클래스 내부에 감추기 위해서이다.
-   외부에서 접근할 필요가 없는 멤버들을 private으로 지정하여 외부에 노출시키지 않음으로써 복잡성을 줄일 수 있다.
-   만약 상속을 통해 확장될 것이 예상되는 클래스라면, 멤버에 접근 제한을 두되 자손 클래스에서 접근하는 것이 가능하도록 하기 위해 private이 아닌 protected를 사용한다.

> 접근 제어자를 사용하는 이유  
> -외부로부터 데이터를 보호하기 위해서  
> -외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

## 다형성(plumorphism)

-   다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미한다.
-   Java에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.  
    ex) 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 함

### ex

조상이 TV, 자식이 CaptionTv 일 때 아래와 같은 코드가 있다고 하자

```java
Tv t = new CaptionTv(); //타입 불일치, 조상 타입의 참조 변수로 자손 인스턴스를 참조
```

참조 변수 t로는 CaptionTv 인스턴스의 모든 멤버를 사용할 수 없다.  
CaptionTv 인스턴스 중, Tv클래스의 멤버들만 사용할 수 있다.

```java
CaptionTv c = new Tv(); //불가능
```

이 코드의 경우는 불가능 하다.  
그 이유는 실제 인스턴스인 Tv()의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문이다.

> 조상 타입의 참조변수로 자손 타입의 인스턴스를 참조할 수 있다.  
> 반대로 자손 타입의 참조변수로 조상 타입의 인스턴스를 참조할 수 없다.

## 참조변수의 형변환

-   참조변수도 형변환이 가능하나, 서로 상속관계에 있는 클래스 사이에서만 가능하다.
-   기본형의 형변환과 달리 참조형의 형변환은 변수에 저장된 값(주소값)이 변환되는 것이 아니다.  
    그저 참조변수를 다른 종류의 것으로 바꾸는 것 뿐이다. (사용할 수 있는 멤버 개수를 조절하기 위함)
-   보통 조상 타입으로의 형변환은 생략할 수 있는데, 이는 조상타입으로 형변환을 하면 다룰 수 있는 멤버의 개수가 줄어들기 때문에 항상 안전하기 때문이다.

> 서로 상속관계에 있는 타입간의 형변환은 양방향으로 자유롭게 수행될 수 있으나, **참조변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다. 그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 먼저 확인하는 것이 중요하다.**

### instanceof 연산자

-   참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 **instanceof 연산자**를 사용한다.
    ![image](https://user-images.githubusercontent.com/70802352/214764765-5ae1460a-2aed-4f08-b3a7-e77d5a680ec9.png)

true일 때만 형변환이 가능하다.

> 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있기 때문에, 참조변수의 차입과 인스턴스의 타입이 항상 일치하는 것은 아니다.

## 여러 종류의 객체를 배열로 다루기

-   조상타입의 참조변수로 자손타입의 객체를 참조하는 것이 가능하므로, Product클래스가 Tv, Computer, Audio 클래스의 조상일 때 아래와 같이 할 수 있다.

```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

-   이처럼 조상타입의 참조변수 배열을 사용하면, 공통의 조상을 가진 서로 다른 종류의 객체를 배열로 묶어서 다룰 수 있다.

## 추상 클래스(abstract)

-   미완성 설계도 => **인스턴스 생성 불가**  
    상속을 통해 자손 클래스에 의해서만 완성될 수 있다.
-   미완성 메서드(추상 메서드)를 포함하고 있는 클래스
-   추상 클래스는 추상 메서드를 포함하고 있다는 것을 제외하면 일반 클래스와 다를게 없다. (생성자, 멤버변수, 메서드 모두 가질 수 있다.)

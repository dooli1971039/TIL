# CH06 객체지향 프로그래밍 1

## 객체지향 언어

1. 코드의 재사용성이 높다
    - 새로운 코드 작성시 기존 코드를 이용하여 쉽게 작성 가능
2. 코드의 관리가 용이하다.
    - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있따.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
    - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오작동을 방지할 수 있다.

## 클래스와 객체

-   클래스: 객체를 정의해 놓은 것
    -   객체를 생성하는데 사용. (객체 그 자체는 아님)
-   객체: 실제로 존재하는 것. 사물 또는 개념
    -   객체가 가지고 있는 기능과 속성에 따라 다름
-   클래스로부터 객체를 만드는 것을 **인스턴스화**라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 **인스턴스**라고 한다.
-   객체의 구성 요소에는 **속성**과 **기능**이 있다.
    1. 속성(property) -> 멤버변수(variable)
    2. 기능(function) -> 메서드(method)

## 객체의 생성과 사용

```java
TV t1 = new TV(); // t1:참조변수
t1.channel = 7;
t1.channelDown();
```

-   인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
-   기본 타입(int)은 실제 값을 변수에 저장하지만, 참조 타입는 메모리 주솟값을 변수 안에 저장한다.

## 객체 배열

-   **Tv[] tvArr = new Tv[3]**는 그저 객체 배열을 생성까지만 했을 뿐, 객체가 저장되지는 않았다.

```java
Tv[] tvArr = new Tv[3];
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[2] = new Tv();

//위에 처럼 하거나 아래처럼 하거나
Tv[] tvArr= {new Tv(), new Tv(), new Tv()};

// for문을 사용하여 객체를 생성해도 된다.
```

## 클래스

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으러 저장할 수 있는 공간
3. 구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : **데이터와 함수의 결합 (구조체 + 함수)**

Q) 자바에서 String이라는 클래스로 문자열을 다루는 이유는?  
A) 문자열을 단순히 문자의 배열로 정의하지 않고, 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위함이다.

## 선언 위치에 따른 변수의 종류

![image](https://user-images.githubusercontent.com/70802352/213233955-88c6a7f0-6b66-4ab6-83a0-130abfaf9013.png)

1. 인스턴스 변수  
   클래스 영역에 선언되며, 인스턴스 생성 시 만들어진다. 따라서 인스턴스 변수의 값을 가져오려면 그 전에 생성을 반드시 해야한다. 인스턴스마다 **별도의 공간**을 가지므로 서로 다른 값을 가질 수 있다.
2. 클래스 변수  
   인스턴스 변수 앞에 **static**키워드만 붙이면 생성할 수 있다. 인스턴스마다 독립적인 저장공간을 갖는 인스턴스 변수와는 달리, 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다. **한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 클래스 변수로 선언**한다.  
   클래스 변수는 인스턴스 생성 없이 바로 사용할 수 있다.
3. 지역 변수  
   메서드 내에 선언되어 매서드 내에서만({} 블럭 내에서만) 사용이 가능함. 메서드가 종료되면 소멸되어 사용할 수 없게 된다.

## 메서드

-   특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
-   선언부(header)와 구현부(body)로 이루어져 있다.
-   메서드를 정의하고 반드시 호출해야 구현부의 문장들이 수행된다.
-   메서드를 호출시 괄호 안에 들어가는 값을 argument, 선언부에 작성하는 값을 parameter라고 한다.

### 선언부

-   선언부는 메서드 이름, 매개변수 선언, 반환 타입으로 구성되어 있다.
-   매개변수가 없다면 빈 괄호로 남겨둔다.
-   일반 변수와 달리, 매개변수는 타입이 같아도 생략이 불가능하다.
-   반환 타입이 없을 경우 void로 적는다.

### 구현부

-   메서드 선언부의 반환 타입이 void가 아닌 경우, 구현부 안에 return문이 반드시 포함되어야 한다.
-   void인 경우 return; 원래는 마지막에 써야 하지만, 안 써도 컴파일러가 자동으로 추가해준다.
-   반환값은 최대 하나만 허용된다.
-   메서드 내에 선언된 변수들은 지역변수라고 한다.

## 호출스택

-   호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다.
-   메서드 호출 시 호출 스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수들과 연산의 중간 결과 등을 저장하는데 사용된다.
-   메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비어진다.
-   한 번에 하나만 실행된다. (나머지는 대기 상태가 된다)

## 매개변수

-   매개변수의 타입이 기본형이면 **값**이 복사되고, 참조형이면 **인스턴스 주소**가 복사된다.
-   주소를 받으면 메서드 안에서 수정이 가능하다.

## static 메서드와 인스턴스 메서드

-   메서드 중에 인스턴스와 관계없는 메서드를 클래스 메서드(static 메서드)라고 정의한다.
-   인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야하는 것은 아니지만 주로 static으로 선언한다.

## static

1. 클래스를 설계할 때, 멤버변수 중 **모든 인스턴스에 공통으로 사용**하는 것에 static을 붙인다.
2. 클래스 변수는 인스턴스를 생성하지 않아도 가용할 수 있다.
3. **클래스 메서드는 인스턴스 변수를 사용할 수 없다.** (메서드 호출 시 인스턴스가 존재하지 않을 수도 있어서)
4. 메서든 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

## 오버로딩

-   한 클래스 내에 같은 이름의 메서드를 여러개 정의하는 것을 **메서드 오버로딩** 또는 **오버로딩**이라 한다.
-   오버로딩이 성립하려면 아래 조건을 만족해야 한다.
    -   메서드 이름이 같아야 한다.
    -   매개변수의 개수 또는 타입이 달라야 한다.
-   반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.

## 생성자

-   인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**이다.
-   인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 하는 작업을 위해서도 사용된다.
-   생성자의 조건은 아래와 같다
    -   생성자의 이름은 클래스의 이름과 같아야 한다.
    -   생성자는 리턴 값이 없다.
-   연산자 new가 인스턴스를 생성하는 것이지, 생성자가 인스턴스를 생성하는 것이 아니다.

## 생성자에서 다른 생성자 호출하기 - this()

-   생성자의 이름으로 클래스이름 대신 this를 사용한다.
-   한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

## 객체 자신을 가리키는 참조변수 - this

-   this는 참조변수로 인스턴스 자신을 가리킨다.
-   참조변수를 통해 인스턴스의 멤버에 접근할 수 있는 것처럼, this로 인스턴스변수에 접근할 수 있다.
-   this를 사용할 수 있는 것은 인스턴스 멤버 뿐이다. static 메서드는 인스턴스를 생성하지 않고도 호출될 수 있으므로 static 메서드가 호출된 시점에 인스턴스가 존재하지 않을 수 있기 때문이다.

## 변수의 초기화

-   멤버변수(클래스 변수와 인스턴스 변수)와 배열의 초기화는 선택 (기본값 들어감)
-   지역변수의 초기화는 필수

### 멤버변수의 초기화

-   자동 초기화 -> 명시적 초기화 -> 초기화 블럭, 생성자
-   클래스 초기화 블럭 : 클래스 변수의 복잡한 초기화에 사용된다. (static {})
-   인스턴스 초기화 블럭 : 인스턴스 변수의 복잡한 초기화에 사용된다. ({})
-   클래스 초기화 블럭은 처음 메모리에 로딩될 때 한번만, 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 수행된다.
